# Crie um arquivo docker-compose para gerenciar uma aplicação Python integrada ao banco de dados
# relacional PostgreSQL

# OBSERVAÇÕES - NÃO ESQUECER DE COLOCAR CADA CONTAINER PARA LER AS VARIÁVEIS DE AMBIENTE
# NO ARQUIVO.env POIS, SE NÃO FIZER ISSO OS CONTAINER POR MAIS QUE ESTEJAM NO MESMO CANAL
# DE COMUNICAÇÃO, REDE VIA TCP, VAI DAR PROBLEMA. POIS O CONTAINER PODE TENTAR PUXAR 
# INFOMRAÇÕES LOCALMENTE AO INVÉS DE FAZER ISSO PELA REDE.

version: "3.9"

# Declarando globalmente os nossos volumes
volumes:
  # definindo o nome do nosso volume 
  pgdata:
    # o driver do nosso volume
    driver: local

# definindo globalmente a nossa network (nossa rede personalizada)
networks:
  # nome da nossa rede, praticamente o nosso canal (pipe) de comunicação entre os containers
  backend:
    # rede padrão gerenciada automaticamente pelo Docker
    driver: bridge

# Definindo o nosso conjunto de containers
services:
  # nome do nosso primeiro container
  integration_test:
    # buildando, criando o nosso container com um Dockerfile
    build:
      # caminho onde está o Dockerfile
      context: .
      # nome do arquivo Dockerfile personalizado
      dockerfile: integration_app.dockerfile
    
    # ordem de dependências dos containers
    depends_on:
      # espera o postgres estar saudável antes de iniciar
      postgres:
        condition: service_healthy
    
    # lendo as variáveis de ambiente no arquivo.env para os dois container se comunicarem
    env_file:
      - .env # nome do arquivo .env

    # conectando o container à rede personalizada
    networks:
      - backend

  # nome do nosso segundo container
  postgres:
    # imagem base do PostgreSQL na versão 15 do alpine
    image: postgres:15.3-alpine
    
    # Definindo um nome para o container
    container_name: postgres

    # restart: reinicia sempre que cair o container ou manualmente
    restart: always
    
    # Definindo as variáveis de ambiente
    
    #environment:
    # - POSTGRES_USER=USER
    # - POSTGRES_PASSWORD=PASSWORD
    # - POSTGRES_DB=DATABASE

    # definindo portas que podem ser mapeadas pelo nosso host
    # primeiro valor é a porta do host e o segundo é o valor interno do container
    ports:
      - "5431:5432"
    
    # Definindo as variáveis de ambiente apartir de um arquivo .env

    env_file:
      - .env # nome do arquivo .env

    # definindo em qual diretório o nosso volume vai estar no container
    volumes:
      - pgdata:/var/lib/postgresql/data

    # conectando o container à rede personalizada
    networks:
      - backend

    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

    # healthcheck para garantir que o Postgres está pronto antes de outros containers tentarem se conectar
    #healthcheck:
      # comando que verifica a disponibilidade do banco usando a variável de ambiente do usuário
      #test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER}"]
      #interval: 5s       # intervalo entre tentativas
      #timeout: 5s        # tempo máximo de espera por tentativa
      #retries: 5         # número de tentativas antes de considerar o serviço como unhealthy
