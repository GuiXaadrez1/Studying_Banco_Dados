# Introdução às Constraints (restrições) em SQL

No contexto de bancos de dados relacionais, uma constraint (ou restrição) é uma regra que impõe limites ou condições sobre os dados em uma tabela. Seu objetivo principal é garantir a integridade, consistência e confiabilidade das informações armazenadas, prevenindo inserções, atualizações ou exclusões que violem as regras de negócio definidas pelo modelo de dados.

Em termos formais, podemos considerar uma constraint como uma função booleana aplicada sobre colunas de uma tabela, que determina se uma determinada operação (INSERT, UPDATE ou DELETE) é válida ou inválida. Caso a operação viole a constraint, o SGBD rejeita a transação e retorna um erro.

## Classificação das Constraints

As constraints podem ser classificadas em diferentes categorias, dependendo de seu propósito:

### Integridade de Entidade:

Garante que cada registro seja único e identificável.

Exemplos: PRIMARY KEY, UNIQUE.

### Integridade Referencial:

Mantém consistência entre tabelas relacionadas.

Exemplo: FOREIGN KEY.

### Integridade de Domínio:

Define valores permitidos ou condições específicas para colunas.

Exemplos: NOT NULL, CHECK, DEFAULT.

### Restrições Avançadas:

Aplicadas em cenários específicos ou operadores complexos.

Exemplo PostgreSQL: EXCLUSION.

### Benefícios do Uso de Constraints

Prevenção de dados inválidos:

- Evita inserções incorretas, duplicadas ou inconsistentes.

Redução de lógica na aplicação:

- Regras de negócio podem ser aplicadas diretamente no banco de dados.

Melhoria da integridade referencial:

- Garante que relacionamentos entre tabelas permaneçam consistentes.

Otimização de consultas:

- Constraints como PRIMARY KEY e UNIQUE são usadas pelo SGBD para indexação automática.

Auditoria e confiabilidade:

- Facilita a rastreabilidade de erros e inconsistências de dados.

### Aplicações Práticas

- Controle de usuários únicos em sistemas web (PRIMARY KEY, UNIQUE).

- Garantia de relacionamentos corretos entre clientes e pedidos (FOREIGN KEY).

- Validação de regras de negócio diretamente no banco (CHECK, NOT NULL).

- Paginação e manipulação de conjuntos de dados (constraints compostas e EXCLUSION).

### Considerações Finais

As constraints são elementos fundamentais da modelagem relacional, permitindo que o banco de dados autocorrija operações inválidas e proteja a integridade dos dados. Sem o uso correto dessas restrições, sistemas críticos podem se tornar vulneráveis a inconsistências, duplicidades e falhas em regras de negócio.

## Constraint (restrição) de PRIMARY KEY (chave primária)

A PRIMARY KEY é a constraint fundamental para garantir a identidade única de cada registro em uma tabela relacional. Ela combina duas propriedades essenciais:

- Unicidade: Nenhum valor duplicado é permitido na coluna ou conjunto de colunas definido como chave primária.

- Não Nulo: Todos os registros devem possuir um valor válido; valores nulos não são aceitos.

A PRIMARY KEY serve como âncora de integridade no banco de dados, permitindo que registros sejam identificados de forma inequívoca e formando a base para relacionamentos com outras tabelas por meio de FOREIGN KEYS.

### Estrutura Sintática

**Chave primária simples:**

```sql
-- No PostgreSql
CREATE TABLE clientes (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    nome TEXT NOT NULL,
    email TEXT
);
```

**Chave primária composta:**

```sql
CREATE TABLE matriculas (
    aluno_id INT,
    curso_id INT,
    data_matricula DATE,
    PRIMARY KEY (aluno_id, curso_id)
);
```

**Observações:**

Uma tabela pode ter apenas uma PRIMARY KEY.

Em chaves compostas, a combinação das colunas deve ser única.

### Exemplos Práticos

Exemplo 1 – Identificação de clientes

```sql
INSERT INTO clientes (nome, email) VALUES ('Ana Silva', 'ana@email.com');
INSERT INTO clientes (nome, email) VALUES ('Pedro Souza', 'pedro@email.com');
```

Cada registro recebe um id único automaticamente pelo tipo SERIAL.

Evita duplicidades e garante referência confiável em outras tabelas.

Exemplo 2 – Chave primária composta em matrículas

```sql
INSERT INTO matriculas (aluno_id, curso_id, data_matricula)
VALUES (1, 101, '2025-08-19');

INSERT INTO matriculas (aluno_id, curso_id, data_matricula)
VALUES (1, 102, '2025-08-20');
```

O mesmo aluno pode se matricular em cursos diferentes, mas não duas vezes no mesmo curso.

### Boas Práticas

- Utilize colunas imutáveis como chave primária (evite emails ou nomes que podem mudar).

- Para tabelas grandes, prefira tipos automáticos (SERIAL, BIGSERIAL) ou UUID.

- Sempre que possível, defina PRIMARY KEY ao criar a tabela para reforçar integridade desde o início.

- Em tabelas de relacionamento muitos-para-muitos, utilize chaves compostas para representar corretamente a unicidade.

### Aplicações Reais

- Identificação de clientes, produtos, pedidos e funcionários em sistemas corporativos.

- Base para chaves estrangeiras e integridade referencial.

- Fundamentais em aplicativos web, ERP, sistemas acadêmicos e bancos de dados transacionais.

## Composite Keys (Chaves Compostas)

Uma Composite Key (ou chave composta) é uma PRIMARY KEY ou UNIQUE que envolve duas ou mais colunas de uma tabela. Ela é usada quando a unicidade de um registro depende da combinação de múltiplos atributos, e não de uma única coluna.

**As chaves compostas são essenciais em cenários de relacionamentos muitos-para-muitos ou quando não existe um identificador único natural para a tabela. Elas garantem integridade de dados e evitam duplicidades em conjuntos de colunas críticos.**

###  Estrutura Sintática

- Chave primária composta:

```sql
CREATE TABLE matriculas (
    aluno_id INT,
    curso_id INT,
    data_matricula DATE,
    PRIMARY KEY (aluno_id, curso_id)
);
```

- Unique composta:

```sql
CREATE TABLE votos (
    usuario_id INT,
    postagem_id INT,
    tipo_voto TEXT,
    UNIQUE (usuario_id, postagem_id)
);
```

Em matriculas, a combinação (aluno_id, curso_id) deve ser única.

Em votos, cada usuário só pode votar uma vez em cada postagem, independentemente do tipo de voto.

### Exemplos Práticos

- Exemplo 1 – Matrículas de alunos:

```sql
INSERT INTO matriculas (aluno_id, curso_id, data_matricula)
VALUES (1, 101, '2025-08-19');

INSERT INTO matriculas (aluno_id, curso_id, data_matricula)
VALUES (1, 102, '2025-08-20');

-- Inserção duplicada para o mesmo aluno e curso gera erro:
-- INSERT INTO matriculas (aluno_id, curso_id, data_matricula)
-- VALUES (1, 101, '2025-08-21');
```

- Exemplo 2 – Votos em postagens:

```sql
INSERT INTO votos (usuario_id, postagem_id, tipo_voto)
VALUES (1, 1001, 'like');

-- Tentar votar novamente na mesma postagem:
-- INSERT INTO votos (usuario_id, postagem_id, tipo_voto)
-- VALUES (1, 1001, 'dislike');  -- Erro: violação da UNIQUE composta
```

### Boas Práticas

- Utilize chaves compostas quando a unicidade depende de múltiplos atributos.

- Evite criar chaves compostas muito grandes (mais de 3–4 colunas), pois isso pode impactar performance e manutenção.

- Considere criar uma chave surrogate (como SERIAL ou UUID) se a chave composta for muito complexa, mas mantenha a UNIQUE sobre as colunas originais para integridade de negócio.

### Aplicações Reais

- Matrículas de alunos em cursos acadêmicos.

- Votos em postagens, curtidas ou reações em sistemas sociais.

- Combinações de produtos em pedidos (produto + tamanho + cor).

- Reservas em hotéis ou passagens, garantindo que não haja duplicidade no mesmo recurso.

## Constraint de FOREIGN KEY (chave estrangeira)

A FOREIGN KEY (chave estrangeira) é uma constraint que estabelece um relacionamento entre duas tabelas, garantindo a integridade referencial do banco de dados. Ela assegura que os valores de uma coluna (ou conjunto de colunas) existam na tabela referenciada, evitando inconsistências e registros órfãos.

Por exemplo, em um sistema de vendas, um pedido não pode existir sem um cliente associado. 

A FOREIGN KEY garante que cada valor na tabela “filha” tenha correspondente na tabela “pai”.

### Estrutura Sintática

**FOREIGN KEY simples:**

```sql
CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    cliente_id INT REFERENCES clientes(id),
    data_pedido DATE
);
```

cliente_id é a coluna que referencia id na tabela clientes.

O banco impede que um pedido seja inserido para um cliente inexistente.

### FOREIGN KEY com ações

```sql
CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    cliente_id INT,
    data_pedido DATE,
    CONSTRAINT fk_cliente
        FOREIGN KEY (cliente_id)
        REFERENCES clientes(id)
        ON DELETE CASCADE -- deleção em massa nas tabelas relacionadas após um delete
        ON UPDATE CASCADE -- atualização nas tabelas relacionadas após um update.
);
```

**ON DELETE CASCADE:** Se o cliente for deletado, os pedidos relacionados também serão removidos.

**ON UPDATE CASCADE:** Se o id do cliente mudar, os pedidos relacionados são atualizados automaticamente.

### Exemplos Práticos

**Exemplo 1 – Integridade simples:**

```sql
INSERT INTO clientes (nome) VALUES ('Carlos Silva');
INSERT INTO pedidos (cliente_id, data_pedido) VALUES (1, '2025-08-19');
```

O pedido só pode ser inserido se o cliente_id existir na tabela clientes.

Tentar inserir cliente_id = 999 resultará em erro.

**Exemplo 2 – Cascade em ação:**

```sql
DELETE FROM clientes WHERE id = 1;
```

Todos os pedidos do cliente 1 serão deletados automaticamente se ON DELETE CASCADE estiver configurado.

### Boas Práticas

Defina FOREIGN KEYS para todas as tabelas dependentes, reforçando integridade referencial.

Utilize ações apropriadas (CASCADE, SET NULL, RESTRICT) conforme a regra de negócio.

Evite chaves estrangeiras circulares complexas, que podem gerar problemas de manutenção.

Para grandes volumes de dados, monitore índices nas colunas de FOREIGN KEY, pois eles impactam performance.

### Aplicações Reais

- Sistemas de vendas: pedidos vinculados a clientes.

- Sistemas acadêmicos: matrículas vinculadas a alunos e cursos.

- ERP: notas fiscais vinculadas a produtos e fornecedores.

- Aplicações web: comentários vinculados a usuários e posts.

## Constraint UNIQUE

A UNIQUE é uma constraint que garante que os valores de uma coluna (ou combinação de colunas) sejam exclusivos em toda a tabela. Diferente da PRIMARY KEY, que combina unicidade e não nulidade e só pode existir uma por tabela, a UNIQUE pode ser aplicada em múltiplas colunas, e colunas UNIQUE podem aceitar valores nulos (dependendo do SGBD).

Essa constraint é essencial para evitar duplicidade de dados, garantindo que informações como emails, CPFs ou códigos de produtos não se repitam, mantendo a integridade e confiabilidade dos registros.

### Estrutura Sintática

- UNIQUE em coluna simples:

```sql
CREATE TABLE usuarios (
    id SERIAL PRIMARY KEY,
    email TEXT UNIQUE,
    nome TEXT
);
```

O banco impede que dois registros tenham o mesmo email.

A coluna email ainda pode ser nula, a depender da implementação do SGBD.

- UNIQUE em múltiplas colunas (composite UNIQUE):

```sql
CREATE TABLE matriculas (
    aluno_id INT,
    curso_id INT,
    data_matricula DATE,
    UNIQUE (aluno_id, curso_id)
);
```

Garante que um mesmo aluno não seja matriculado duas vezes no mesmo curso.

Permite duplicidade individual de aluno_id ou curso_id, mas não da combinação.

### Exemplos Práticos

- Exemplo 1 – Unicidade de email

```sql

INSERT INTO usuarios (email, nome) VALUES ('ana@email.com', 'Ana Silva');
INSERT INTO usuarios (email, nome) VALUES ('pedro@email.com', 'Pedro Souza');

-- Inserção duplicada gerará erro:
-- INSERT INTO usuarios (email, nome) VALUES ('ana@email.com', 'Ana Oliveira');
```

- Exemplo 2 – Unique composta em matrículas:

```sql
INSERT INTO matriculas (aluno_id, curso_id, data_matricula) VALUES (1, 101, '2025-08-19');
INSERT INTO matriculas (aluno_id, curso_id, data_matricula) VALUES (1, 102, '2025-08-20');
-- Inserção duplicada para mesmo aluno e curso gera erro:
-- INSERT INTO matriculas (aluno_id, curso_id, data_matricula) VALUES (1, 101, '2025-08-21');
```

### Boas Práticas

Utilize UNIQUE para colunas que exigem identificadores naturais, como CPF, email ou códigos de produtos.

Em chaves compostas, aplique UNIQUE para representar restrições de negócio específicas.

Lembre-se que colunas UNIQUE ainda podem aceitar NULL, dependendo do SGBD, então verifique se é necessário combinar com NOT NULL.

### Aplicações Reais

- Garantia de emails únicos em sistemas de login.

- Códigos de produtos ou SKU em e-commerce.

- Matrículas de alunos em cursos sem duplicidade.

- Sistemas financeiros: contas, cartões ou notas fiscais com números exclusivos.

##  Constraint NOT NULL

A constraint NOT NULL é uma das mais básicas e essenciais no SQL. Ela impede que uma coluna aceite valores nulos, garantindo que todos os registros possuam um valor válido para aquela coluna.

Enquanto PRIMARY KEY e UNIQUE também implicam em não nulidade, o NOT NULL pode ser aplicado isoladamente a qualquer coluna, independentemente de ser chave ou não. É uma ferramenta essencial para manter consistência de dados e reduzir a necessidade de verificações na aplicação.

## Estrutura Sintática

- NOT NULL em coluna simples:

```sql
CREATE TABLE produtos (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL,
    preco NUMERIC NOT NULL
);
```

- NOT NULL em múltiplas colunas:

```sql
CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    cliente_id INT NOT NULL,
    data_pedido DATE NOT NULL
);
```

Todas as colunas definidas como NOT NULL devem receber valores na inserção de registros.

Caso contrário, o banco retorna erro.

### Exemplos Práticos

- Exemplo 1 – Inserção válida:

```sql
INSERT INTO produtos (nome, preco) VALUES ('Notebook', 3500.00);
```

Aceito porque todas as colunas NOT NULL receberam valores.

- Exemplo 2 – Inserção inválida:

```sql
-- Tenta inserir sem preço
INSERT INTO produtos (nome) VALUES ('Mouse');
-- Erro: coluna "preco" não permite valor nulo
```

### Boas Práticas

- Defina NOT NULL para colunas críticas que devem sempre possuir dados.

- Combine NOT NULL com DEFAULT quando for desejável preencher automaticamente valores padrão.

- Evite colunas NOT NULL desnecessárias, especialmente se nem todos os registros tiverem valor garantido.

### Aplicações Reais

- Campos obrigatórios em formulários web, como nome, email ou senha.

- Preço e estoque em produtos de e-commerce.

- Data de criação de registros em sistemas corporativos.

- Dados essenciais para relatórios ou análises estatísticas.

## Constraint CHECK

A constraint CHECK permite definir condições lógicas que os valores de uma coluna ou conjunto de colunas devem satisfazer. Diferente de NOT NULL ou UNIQUE, que impõem restrições simples, o CHECK possibilita validar regras de negócio complexas diretamente no banco de dados, garantindo integridade de dados conforme políticas internas da aplicação.

Por exemplo, é possível restringir o valor de uma coluna de salário para ser sempre positivo ou limitar a idade de um usuário dentro de um intervalo aceitável.

### Estrutura Sintática

- CHECK em coluna simples:

```sql
CREATE TABLE funcionarios (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL,
    salario NUMERIC CHECK (salario > 0)
);
```

- CHECK em múltiplas colunas:

```sql
CREATE TABLE reservas (
    id SERIAL PRIMARY KEY,
    data_inicio DATE NOT NULL,
    data_fim DATE NOT NULL,
    CHECK (data_fim > data_inicio)
);
```

O CHECK avalia a expressão booleana; se o valor inserido não satisfizer a condição, a operação é rejeitada.

### Exemplos Práticos

- Exemplo 1 – Salário positivo:

```sql
INSERT INTO funcionarios (nome, salario) VALUES ('Ana Silva', 3000);
-- Aceito

INSERT INTO funcionarios (nome, salario) VALUES ('Pedro Souza', -500);
-- Erro: violação da constraint CHECK
```

- Exemplo 2 – Data de reserva:

```sql
INSERT INTO reservas (data_inicio, data_fim) VALUES ('2025-08-20', '2025-08-22');
-- Aceito

INSERT INTO reservas (data_inicio, data_fim) VALUES ('2025-08-25', '2025-08-24');
-- Erro: data_fim menor que data_inicio
```

### Boas Práticas

- Use CHECK para validar regras de negócio que não podem ser garantidas por NOT NULL ou UNIQUE.

- Combine com NOT NULL quando necessário para reforçar a integridade.

- Evite expressões complexas que possam impactar a performance de inserts e updates em grandes tabelas.

### Aplicações Reais

- Garantir salários, preços ou quantidades positivos.

- Validar datas de início e fim de eventos ou reservas.

- Restrições de idade ou limites de pontuação em sistemas de cadastro ou jogos.

- Regras de status, como somente valores específicos de enumeração (ex.: 'Ativo', 'Inativo').

## Constraint DEFAULT

A constraint DEFAULT define um valor padrão para uma coluna quando nenhum valor é especificado durante a inserção de um registro. Diferente de NOT NULL, que impede valores nulos, o DEFAULT permite que a coluna receba automaticamente um valor pré-determinado, garantindo consistência de dados sem necessidade de intervenção da aplicação.

O uso do DEFAULT é especialmente útil para campos opcionais que ainda precisam de valores coerentes para cálculos, relatórios ou relatórios estatísticos.

### Estrutura Sintática

- DEFAULT em coluna simples:

```sql
CREATE TABLE pedidos (
    id SERIAL PRIMARY KEY,
    data_pedido DATE DEFAULT CURRENT_DATE,
    status TEXT DEFAULT 'PENDENTE'
);
```

data_pedido recebe a data atual se nenhum valor for fornecido.

status recebe 'PENDENTE' por padrão.

- DEFAULT com tipos numéricos:

```sql
CREATE TABLE produtos (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL,
    estoque INT DEFAULT 0
);
```

estoque inicializa automaticamente com zero se não for informado.

### Exemplos Práticos

- Exemplo 1 – Inserção sem especificar valores:

```sql
INSERT INTO pedidos (id) VALUES (DEFAULT);
-- data_pedido será preenchida com a data atual
-- status será preenchido com 'PENDENTE'
```

- Exemplo 2 – Combinação com NOT NULL:

```sql
CREATE TABLE funcionarios (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL,
    salario NUMERIC DEFAULT 1500 NOT NULL
);

INSERT INTO funcionarios (nome) VALUES ('Ana Silva');
-- salario será automaticamente 1500
```

###  Boas Práticas

- Utilize DEFAULT para valores padrão de campos opcionais ou críticos para cálculos.

- Combine DEFAULT com NOT NULL para garantir consistência sem depender de inserções explícitas.

- Prefira valores coerentes com o domínio do negócio, evitando defaults genéricos que possam gerar inconsistência em relatórios.

### Aplicações Reais

- Status padrão de pedidos: 'PENDENTE', 'EM PROCESSAMENTO', 'FINALIZADO'.

- Estoque inicial de produtos ou quantidade de itens disponíveis.

- Datas automáticas de criação ou atualização de registros.

- Salários ou valores monetários padrão em tabelas de cadastro de funcionários ou contratos.

## EXCLUSION (PostgreSQL específico)

A constraint EXCLUSION é uma feature avançada do PostgreSQL que permite impedir combinações de valores que entrem em conflito com base em operadores definidos pelo usuário ou pelo sistema. Diferente de UNIQUE, que garante apenas valores distintos, o EXCLUSION possibilita restrições complexas, como sobreposição de intervalos, colisão de horários ou condições customizadas de conflito.

Essa constraint é particularmente útil em cenários de agendamento, reservas e geolocalização, onde múltiplos registros não podem coexistir se satisfizerem uma determinada condição de conflito.

### Estrutura Sintática

```sql
CREATE TABLE tabela_nome (
    coluna1 tipo,
    coluna2 tipo,
    ...,
    CONSTRAINT nome_constraint
        EXCLUDE USING indice_tipo (coluna1 operador, coluna2 operador, ...)
);
```

- indice_tipo: geralmente gist ou spgist para tipos que suportam intervalos, geometria ou timestamps.

- operador: define a regra de conflito, como = para igualdade ou && para sobreposição de intervalos.

### Exemplos Práticos

- Exemplo 1 – Agendamento de reservas sem sobreposição:

```sql
CREATE TABLE reservas (
    id SERIAL PRIMARY KEY,
    sala_id INT NOT NULL,
    periodo TSRANGE NOT NULL,
    EXCLUDE USING gist (sala_id WITH =, periodo WITH &&)
);
```

TSRANGE define o intervalo de tempo da reserva.

A constraint impede que duas reservas da mesma sala se sobreponham.

- Exemplo 2 – Intervalos geográficos:

```sql
CREATE TABLE zonas (
    id SERIAL PRIMARY KEY,
    area GEOGRAPHY(POLYGON),
    EXCLUDE USING gist (area WITH &&)
);
```

Garante que áreas geográficas não se sobreponham em registros diferentes.

## Boas Práticas

- Use EXCLUSION apenas quando UNIQUE ou CHECK não forem suficientes para evitar conflitos complexos.

- Combine com tipos de índices adequados (gist, spgist) para performance.

- Teste exaustivamente cenários de inserção e atualização, pois EXCLUSION pode gerar erros inesperados se operadores forem mal definidos.

### Aplicações Reais

- Reservas de salas, horários ou equipamentos sem sobreposição.

- Registro de zonas geográficas, polígonos ou áreas de cobertura que não podem se sobrepor.

- Eventos em calendário corporativo com restrição de horários conflitantes.

- Sistemas de logística ou transporte com intervalos de rota ou carga que não podem coincidir.

