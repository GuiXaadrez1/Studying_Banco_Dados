## Introdução Teórica - Índices (Indexes) em PostgreSQL

Um índice é uma estrutura de dados auxiliar que melhora significativamente a velocidade de consulta em tabelas de banco de dados. Ele funciona de forma semelhante ao índice de um livro: permite localizar rapidamente os registros sem precisar percorrer toda a tabela.

No PostgreSQL, índices podem ser aplicados a uma ou mais colunas, e diferentes tipos de índices oferecem otimizações para pesquisas, ordenações e restrições específicas.

Benefícios de um índice:

- Acelera consultas SELECT, especialmente em colunas filtradas com WHERE, JOIN ou ORDER BY.

- Suporta constraints, como PRIMARY KEY e UNIQUE.

- Facilita buscas por padrões em colunas de texto ou JSON (com operadores específicos).

Limitações:

- Aumenta o espaço em disco.

- Pode diminuir a performance de inserts, updates e deletes, pois o índice precisa ser atualizado.

- Nem toda consulta se beneficia de índices; para tabelas muito pequenas, o ganho é irrelevante.

## Tipos de Índices no PostgreSQL

### B-Tree (default)

Adequado para igualdade e comparação (=, <, <=, >, >=).

Usado por PRIMARY KEY e UNIQUE por padrão.

### Hash

Otimizado para igualdade (=) apenas.

Não suporta ordenação.

### GIN (Generalized Inverted Index)

Ideal para colunas de array, JSON, ou texto com busca full-text.

### GiST (Generalized Search Tree)

Suporta operações complexas, como intervalos, geometria e sobreposição.

### BRIN (Block Range Index)

Eficiente para tabelas muito grandes com dados sequenciais.

## Estrutura Sintática

### Criar índice simples

```sql
CREATE INDEX idx_nome_coluna
ON tabela (coluna);
```

### Criar índice único
```sql
CREATE UNIQUE INDEX idx_email_unico
ON usuarios (email);
```

### Criar índice composto
```sql
CREATE INDEX idx_aluno_curso
ON matriculas (aluno_id, curso_id);
```

### Índices especializados (GIN)

```sql
CREATE INDEX idx_texto_fulltext
ON documentos
USING GIN (to_tsvector('portuguese', conteudo));
```

### Exemplos Práticos

- Exemplo 1 – Índice B-Tree simples:

```sql
CREATE INDEX idx_clientes_nome
ON clientes (nome);

SELECT * FROM clientes
WHERE nome = 'Ana Silva';
```

A consulta será mais rápida, especialmente em tabelas grandes.

- Exemplo 2 – Índice composto:

```sql
CREATE INDEX idx_matriculas_aluno_curso
ON matriculas (aluno_id, curso_id);

SELECT * FROM matriculas
WHERE aluno_id = 1 AND curso_id = 101;
```

- Exemplo 3 – Índice GIN para busca full-text:

```sql
CREATE INDEX idx_documentos_texto
ON documentos
USING GIN (to_tsvector('portuguese', conteudo));

SELECT * FROM documentos
WHERE to_tsvector('portuguese', conteudo) @@ to_tsquery('PostgreSQL & índice');
```

Permite busca eficiente por palavras ou combinações de palavras no texto.

## Boas Práticas

- Crie índices somente nas colunas mais usadas em consultas, filtros ou joins.

- Evite criar muitos índices em tabelas que sofrem muitas inserções e atualizações, para não degradar performance.

- Use índices compostos quando múltiplas colunas são frequentemente consultadas juntas.

- Considere índices parciais para subconjuntos de dados relevantes:

```sql
CREATE INDEX idx_pedidos_ativos
ON pedidos (cliente_id)
WHERE status = 'ATIVO';
```

- Utilize EXPLAIN para analisar planos de execução e verificar se o índice está sendo aproveitado.

## Aplicações Reais

- Sistemas de e-commerce: busca rápida por produtos, categorias e preços.

- Redes sociais: consultas rápidas por posts, likes ou seguidores.

- Sistemas de reservas: pesquisa por datas e horários disponíveis.

- Análise de grandes volumes de dados: relatórios e dashboards otimizados.