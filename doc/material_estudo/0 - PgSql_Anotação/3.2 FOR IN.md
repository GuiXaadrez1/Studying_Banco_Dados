# Introdução
O laço de repetição (estrutura de repetição) FOR ao contrário do WHILE, sabemos o números de vezes que a lógica de programação, instrução, comando serão executados dentor do escopo desta estrutura.

## Sintaxe Básixa comentada
Em plpgsql a sintaxe segue da seguinte forma, vamos mostrar o FOR tradicional:

```sql
DO $$
    DECLARE
    
    BEGIN
        -- COLOCANDO A SINTAXE BÁSICA DO NOSSO FOR EM PLPGSQL
        FOR variável IN i..j LOOP
            instrução/comando1;
            instrução/comando2;
            ...
            
            -- OS COMANDO SÃO EXECUTADOS EXATAMENTE (j-i+1) vezes
            
            -- VEJA ESSE IN i..j como o nosso RANGE(inicio,fim,intervalo) do python
            
            /* Exemplo em python:

                for i in range(0,10,2):
                    i += 1
                    print(i)

                isso que dizer, faça um laço de repetição de 0 a 9, pulando de duas em duas casas, e incremente, some i+1 a cada ITERAÇÃO neste laço de repetição

                SAIDA:
                    1
                    2
                    3
                    4
                    5               
            */
        END LOOP;

        /*
            *Resumindo como vai funcionar o incremente do iterador(incrementador) a cada ITERAÇÃO (quantidade de vezes que o for é percorrido!):

            A variável será inicializada com o valor de i e será incrementada em uma unidade a cada vez que o bloco interno que o bloco for executado. Então, saimos do laço quando a variável atingir o valor de j.
        */
    END;
$$ Language plpgsql;
```

### Resumindo tudo acima da minha forma
```sql
DO$$
    DECLARE
    BEGIN
        FOR variável IN inicio(I), incremento(..), final (J) LOOP
            -- instruções/comandos...;
        END FOR;
    END;
$$
Language plpgsql;
```

## VARIAÇÕES DO FOR

aqui é uma variação do for tradicional ao qual o laço é executado de k em k após cada bloco ser executado, faz-se automaticamente i = i + k.

```sql
DO$$
    DECLARE
    BEGIN 
        FOR variável IN inicio(I), incremento(..), final (J) BY k LOOP
            -- instruções/comandos...;
        END FOR;
    END;
$$
Language plpgsql;
```

### FOR DECREMENTANDO OS VALORES
ao invés de incrementação i++, fazemos o oposto: i--, para isso colocamos a palavra chave IN REVERSE

```sql
DO$$
    DECLARE
    BEGIN
        FOR variável IN REVERSE inicio(I), incremento(..), final (J) LOOP
            -- instruções/comandos...;
        END FOR;
    END;
$$
Language plpgsql;
```

Fazendo a mesma coisa com a decrementação em k unidades

```sql
DO$$
    DECLARE
    BEGIN
        FOR variável IN REVERSE inicio(I), incremento(..), final (J) BY k LOOP
            -- instruções/comandos...;
        END FOR;
    END;
$$
Language plpgsql;
```

## FOR EACH/FOR EACH ROW

No PL/pgSQL, o FOR EACH não existe isolado — mas o conceito é FOR com cursor iterando linha por linha.
No PostgreSQL, o FOR EACH ROW aparece na sintaxe de TRIGGERS, não em loops.

### FOR EACH ROW → Usado em TRIGGER

No CREATE TRIGGER, você indica FOR EACH ROW pra dizer:

    "Para cada linha afetada por este evento, dispare a função de trigger".
Exemplo real:

```sql
CREATE TRIGGER trg_auditoria
    AFTER UPDATE ON produto
    FOR EACH ROW -- <- dispara para cada linha modificada
EXECUTE FUNCTION auditar_update();
```

Na função RETURNS TRIGGER, você trata uma linha por vez:

```sql
CREATE OR REPLACE FUNCTION auditar_update() RETURNS TRIGGER 
AS $$
    BEGIN
        INSERT INTO log_produto (produto_id, data_modificacao)
        VALUES (NEW.id, now());
        RETURN NEW;
    END;
$$ 
LANGUAGE plpgsql;
```

### FOR ... LOOP → Usado em PL/pgSQL para percorrer resultados
Quando você quer percorrer linhas dentro de uma função ou bloco anônimo, você faz:

```sql

FOR registro IN
  SELECT ... 
LOOP
  -- faça algo com registro.coluna
END LOOP;
```

Sintaxe básica:

```sql
DO $$
DECLARE
  rec RECORD;
BEGIN
  FOR rec IN
    SELECT id, nome FROM produto WHERE preco > 100
  LOOP
    RAISE NOTICE 'ID: %, Nome: %', rec.id, rec.nome;
  END LOOP;
END;
$$ 
LANGUAGE plpgsql; 
```

⚙️ Etapas explicadas:

- 1️⃣ DECLARE rec RECORD; → cria uma variável do tipo RECORD.
- 2️⃣ FOR rec IN SELECT ... LOOP → faz o cursor implícito.
- 3️⃣ Dentro do LOOP você manipula cada linha individualmente.
- 4️⃣ Não precisa abrir/fechar cursor manual — o FOR ... IN SELECT faz isso automaticamente.

### Diferença fundamental

| Conceito       | Uso                                                                               |
| -------------- | --------------------------------------------------------------------------------- |
| `FOR EACH ROW` | Só em `TRIGGER`. Executa a **função de gatilho** **uma vez por linha afetada**.   |
| `FOR ... LOOP` | Dentro de **função PL/pgSQL** normal ou `DO`. Itera **resultado de um `SELECT`**. |


## Exemplos de uso
Exemplo 1:

```sql
DO$$
BEGIN
    FOR counter IN 1..5 LOOP
        RAISE NOTICE 'Counter: %', counter;
        -- Raise notice é um print, printr(), console.log()
        -- ele exibe um comentário, texto na tela...
        -- o % em algumas libs de integração banco de dados e linguagem de programação
        -- chamamos de place holder que vai referenciar uma variável
        -- a ordem de importa na hora de referenciar esse place holder para uma variável
    END LOOP;
END;
$$
Language plpgsql;

/*
SAIDA:
NOTICE Counter: 1
NOTICE Counter: 2
NOTICE Counter: 3
NOTICE Counter: 4
NOTICE Counter: 5
*/
```

Exemplo 2:

```sql
DO$$
BEGIN
    FOR counter IN 1..6 BY 2 LOOP
        RAISE NOTICE 'Counter: %', counter;
        -- Ele irá exibir na tela a mensagem de duas em duas iterações
    END LOOP;
END;
$$
Language plpgsql;

/*SAIDA:
NOTICE Counter: 1
NOTICE Counter: 3
NOTICE Counter: 5
*/
```

Exemplo 3, fatorial com FOR:

```sql
CREATE OR REPLACE FUNCTION for_fat(IN n_positivo INTEGER) RETURNS INTEGER
AS $$
    DECLARE
        fat INTEGER := 1  
        i INTEGER  := 2
    BEGIN
        IF n_positivo > 0 THEN 
            IF n_positivo < 2 THEN
                RETURN fat;
            ELSE
                FOR i IN 1..n_positivo LOOP
                    fat := fat * i
                END LOOP;
                RETURN fat;
        ELSE   
            RETURN -1;
        END IF;
    END;
$$
Language plpgsql;
```
